好的，为了确保内容的详尽性和专业性，我将为您准备三份独立的文档：

1. **文档一：RTP 协议深度剖析 (Real-time Transport Protocol)**
    
    - **重点**：RTP 协议头、RTCP 控制协议、网络传输特性。
        
2. **文档二：H.264 编码格式完全解析 (H.264/AVC Structure)**
    
    - **重点**：VCL/NAL 层、NALU 结构、SPS/PPS 参数集。
        
3. **文档三：多媒体格式在 RTP 中的负载封装 (Payload Formats)**
    
    - **重点**：H.264 (RFC 6184)、H.265 (RFC 7798)、AAC (RFC 3640) 的打包策略与 C++ 实现逻辑。
        

---

# 文档一：RTP 协议深度剖析 (Real-time Transport Protocol)

> 核心标准：IETF RFC 3550
> 
> 定位：流媒体传输的基石，提供端到端的网络传输功能，适用于传输实时数据（如音频、视频）。

## 1. RTP 协议架构与位置

RTP 通常运行在 **UDP** 之上，虽然也可以运行在 TCP 上（如 RTSP over TCP），但 UDP 是其原生环境。RTP 本身不保证服务质量（QoS），也不保证按序到达，这些由上层应用配合 RTCP 来处理。

## 2. RTP 固定报头 (Fixed Header) —— 比特级详解

这是 RTP 数据包最核心的部分，共 12 字节（96 bits）。

|**字段 (Field)**|**位宽**|**名称**|**详细定义与架构师解读**|
|---|---|---|---|
|**V** (Version)|2 bits|版本号|**固定值 `10` (即 2)**。目前广泛使用的版本是 RTP v2。|
|**P** (Padding)|1 bit|填充位|**0**: 无填充。<br><br>  <br><br>**1**: 包末尾有填充字节。最后一个字节存储填充长度。用于加密算法对齐块大小。|
|**X** (Extension)|1 bit|扩展位|**0**: 无扩展头。<br><br>  <br><br>**1**: 固定头后紧跟一个扩展头。常用于 WebRTC 音量信息等私有数据。|
|**CC** (CSRC Count)|4 bits|CSRC 计数|表示紧跟在 RTP 头后的 CSRC 标识符个数。通常单播流为 0。|
|**M** (Marker)|1 bit|标记位|**关键位**。含义由 Profile 决定。<br><br>  <br><br>• **视频 (H.264)**: 表示一帧的**最后一个** RTP 包。<br><br>  <br><br>• **音频**: 表示谈话突发开始（Talkspurt start）。|
|**PT** (Payload Type)|7 bits|载荷类型|标识数据格式。<br><br>  <br><br>• **静态类型**: `0`=PCMU, `8`=PCMA, `10`=L16。<br><br>  <br><br>• **动态类型 (96-127)**: H.264/H.265 通常协商为 `96`。|
|**Sequence Number**|16 bits|序列号|每发送一个 RTP 包，值 `+1`。初始值随机。<br><br>  <br><br>**作用**：接收端检测丢包、统计丢包率、乱序重排。|
|**Timestamp**|32 bits|时间戳|记录采样时刻。单位是时钟频率 (Clock Rate)，不是毫秒。<br><br>  <br><br>**视频**: 90kHz (1ms = 90 ticks)。同一帧的所有 RTP 包时间戳相同。<br><br>  <br><br>**音频**: 44.1kHz / 48kHz 等。|
|**SSRC**|32 bits|同步信源 ID|随机生成，全局唯一。标识**同一个流**。例如一个会话中音频流和视频流有不同的 SSRC。|
|**CSRC**|32 bits * CC|特约信源 ID|仅当混音器 (Mixer) 存在时使用，列出所有贡献源的 SSRC。|

### C++ 结构体定义 (内存对齐版)

C++

```
// 注意：网络字节序通常是大端 (Big-Endian)，x86 是小端，直接强转需处理位域顺序或使用 ntohl/htonl
struct RtpHeader {
#ifdef __BIG_ENDIAN__
    uint8_t version:2;
    uint8_t padding:1;
    uint8_t extension:1;
    uint8_t csrc_count:4;
    
    uint8_t marker:1;
    uint8_t payload_type:7;
#else // Little Endian (x86/ARM)
    uint8_t csrc_count:4;
    uint8_t extension:1;
    uint8_t padding:1;
    uint8_t version:2;
    
    uint8_t payload_type:7;
    uint8_t marker:1;
#endif
    uint16_t sequence_number; // 需要 htons/ntohs
    uint32_t timestamp;       // 需要 htonl/ntohl
    uint32_t ssrc;            // 需要 htonl/ntohl
    // CSRC 列表紧跟其后，不固定长度
};
```

## 3. RTCP (RTP Control Protocol) —— 质量反馈

RTP 负责运货，RTCP 负责签收单。RTCP 包通常使用 **RTP 端口 + 1**。

- **SR (Sender Report)**: 发送端报告。包含发送了多少包、多少字节、NTP 时间戳（用于音画同步）。
    
- **RR (Receiver Report)**: 接收端报告。包含**丢包率**、**Jitter (抖动)**、最高序列号。
    

> **架构师提示**：如果你做 WebRTC 或弱网对抗，RTCP 的 RR 包中的 Jitter 和丢包率是计算 NACK (重传) 和调整码率 (GCC/TCC) 的核心依据。

---

# 文档二：H.264 编码格式完全解析 (H.264/AVC Structure)

> 核心标准：ISO/IEC 14496-10 (AVC)
> 
> 定位：视频压缩标准，定义了比特流的语法和语义。

## 1. VCL 与 NAL 架构

H.264 创新性地分为了两层：

- **VCL (Video Coding Layer)**: 视频编码层。负责内容的压缩（I帧、P帧、B帧的宏块数据）。
    
- **NAL (Network Abstraction Layer)**: 网络提取层。负责将 VCL 数据打包成适合网络传输的单元（NALU）。
    

## 2. NAL Unit (NALU) 结构

H.264 码流就是由一个个 NALU 组成的。

### 2.1 Annex-B 格式 (文件存储)

在 `.h264` 或 `.mp4` (dat) 文件中，NALU 之间通过 **Start Code** 分隔。

- **Start Code**: `00 00 00 01` (4字节) 或 `00 00 01` (3字节)。
    
- **防竞争 (Emulation Prevention)**: 如果数据内部出现了 `00 00 01`，编码器会插入 `03` 变成 `00 00 03 01`。解码时需去除 `03`。
    

### 2.2 NAL Header (1 Byte) —— 重点

每个 NALU 的第一个字节是 Header。

|**Bit**|**名称**|**含义**|
|---|---|---|
|**0** (1 bit)|`forbidden_zero_bit`|**必须为 0**。若为 1，视为错误包。|
|**1-2** (2 bits)|`nal_ref_idc` (NRI)|**重要性指示**。<br><br>  <br><br>`00`: 非参考帧 (如 B 帧)，可丢弃。<br><br>  <br><br>`11`: 关键参数 (SPS/PPS/IDR)，绝不可丢。|
|**3-7** (5 bits)|`nal_unit_type`|**NALU 类型**。|

### 2.3 关键 NALU Type 速查表

|**Type (Dec)**|**Type (Hex)**|**名称**|**说明**|**NRI (常见)**|
|---|---|---|---|---|
|**1**|0x01|**Slice (Non-IDR)**|非关键帧 (P/B 帧) 图像数据|2 或 0|
|**5**|0x05|**IDR Slice**|关键帧 (I 帧)。解码器必须立即刷新缓冲区。|3 (11)|
|**6**|0x06|**SEI**|补充增强信息 (字幕、时间码等)|0|
|**7**|0x07|**SPS**|序列参数集 (分辨率、帧率、Profile)|3 (11)|
|**8**|0x08|**PPS**|图像参数集 (熵编码模式等)|3 (11)|
|**24-31**|-|**RTP 专用**|STAP-A, FU-A 等 (见文档三)|-|

> 判断是否关键帧：
> 
> C++ 代码中判断是否为关键帧通常看 type == 5。但更严谨的做法是：如果 type == 7 (SPS) 或 type == 8 (PPS) 也通常伴随 IDR 帧。

---

# 文档三：多媒体格式在 RTP 中的负载封装 (Payload Formats)

> 核心标准：RFC 6184 (H.264), RFC 7798 (H.265)
> 
> 定位：解决“如何把巨大的视频帧塞进限制大小的 UDP 包中”的问题。

## 1. 打包策略概览

由于以太网 **MTU** (Maximum Transmission Unit) 通常为 1500 字节，除去 IP 头 (20) + UDP 头 (8) + RTP 头 (12) = 40 字节，**RTP Payload 最好不要超过 1460 字节**（保险起见常设为 1400）。

- **小包** (如 SPS/PPS/SEI) -> **单一 NALU 模式** 或 **聚合模式 (STAP-A)**。
    
- **大包** (如 I 帧/P 帧，动辄几十 KB) -> **分片模式 (FU-A)**。
    

## 2. H.264 over RTP (RFC 6184)

### 2.1 模式一：单一 NALU 模式 (Single NAL Unit)

适用：Payload < 1400 字节。

封装：直接把 NALU (去掉 Start Code) 放在 RTP 头后面。

Plaintext

```
[ RTP Header ] [ NAL Header ] [ NAL Payload ... ]
```

- **RTP Header `M` 位**：若该 NALU 是一帧的结束，置 1；否则置 0。
    

### 2.2 模式二：分片模式 FU-A (Fragmentation Unit A)

适用：Payload > 1400 字节。

机制：将一个 NALU 拆分。原 NAL Header 被丢弃，取而代之的是 FU Indicator 和 FU Header。

#### FU Indicator (1 Byte)

Plaintext

```
+---------------+
|0|1|2|3|4|5|6|7|
+-+-+-+-+-+-+-+-+
|F|NRI|  Type   |
+---------------+
```

- **F**: 继承原 NALU 的 F。
    
- **NRI**: 继承原 NALU 的 NRI。
    
- **Type**: **28** (FU-A 的标志)。
    

#### FU Header (1 Byte)

Plaintext

```
+---------------+
|0|1|2|3|4|5|6|7|
+-+-+-+-+-+-+-+-+
|S|E|R|  Type   |
+---------------+
```

- **S (Start)**: 1 表示这是分片的第一个包。
    
- **E (End)**: 1 表示这是分片的最后一个包。
    
- **R (Reserved)**: 0。
    
- **Type**: **原 NALU 的 Type** (例如 IDR 就是 5)。
    

### 2.3 C++ 伪代码：H.264 FU-A 打包逻辑

C++

```
// 假设 input_nalu 包含 StartCode 之后的完整数据
void RtpPackerH264::Pack(const uint8_t* input_nalu, int nalu_len, uint32_t timestamp) {
    const int kMtuSize = 1400;
    uint8_t nalu_header = input_nalu[0];
    int nalu_type = nalu_header & 0x1F;
    int nalu_nri = nalu_header & 0x60;
    
    // 跳过 NALU Header，只处理负载
    const uint8_t* payload = input_nalu + 1;
    int payload_len = nalu_len - 1;

    // --- Case 1: 单一 NALU 模式 ---
    if (nalu_len <= kMtuSize) {
        RtpPacket packet;
        packet.header.marker = 1; // 假设每帧一个 NALU
        packet.header.timestamp = timestamp;
        // 直接拷贝整个 NALU (含 Header)
        memcpy(packet.payload, input_nalu, nalu_len);
        SendUDP(packet);
        return;
    }

    // --- Case 2: FU-A 分片模式 ---
    int offset = 0;
    bool is_first = true;
    
    while (offset < payload_len) {
        int space_left = kMtuSize - 2; // 减去 FU Indicator 和 FU Header
        int fragment_len = std::min(space_left, payload_len - offset);
        bool is_last = (offset + fragment_len == payload_len);

        RtpPacket packet;
        packet.header.timestamp = timestamp;
        packet.header.marker = is_last ? 1 : 0; // 只有最后一个包 M=1

        uint8_t* ptr = packet.payload;
        
        // 1. FU Indicator
        // F=0, NRI=原NRI, Type=28
        ptr[0] = 0x00 | nalu_nri | 28;

        // 2. FU Header
        // S=?, E=?, R=0, Type=原Type
        ptr[1] = (is_first ? 0x80 : 0x00) | (is_last ? 0x40 : 0x00) | nalu_type;

        // 3. Copy Payload
        memcpy(ptr + 2, payload + offset, fragment_len);

        SendUDP(packet);

        offset += fragment_len;
        is_first = false;
    }
}
```

## 3. H.265 over RTP (RFC 7798)

H.265 (HEVC) 的打包与 H.264 非常相似，但头部结构略有不同。

### 3.1 NALU Header (2 Bytes)

H.265 的头是 2 个字节。

Plaintext

```
+---------------+---------------+
|0|1|2|3|4|5|6|7|0|1|2|3|4|5|6|7|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|F|   Type    |  LayerId  | TID |
+---------------+---------------+
```

- **F**: 0
    
- **Type (6 bits)**: NALU 类型。0-31 VCL, 32-40 非 VCL (VPS/SPS/PPS)。
    
- **LayerId (6 bits)**: 0 (普通流)。
    
- **TID (3 bits)**: Temporal ID + 1。通常为 1。
    

### 3.2 H.265 FU 分片 (Fragmentation Unit)

结构由 **Payload Header (2 Bytes)** + **FU Header (1 Byte)** 组成，共 3 字节开销。

- **Payload Header**: Type 固定为 **49** (FU)。F, LayerId, TID 继承自原 NALU。
    
- **FU Header**:
    
    Plaintext
    
    ```
    +---------------+
    |0|1|2|3|4|5|6|7|
    +-+-+-+-+-+-+-+-+
    |S|E|  Type     |
    +---------------+
    ```
    
    - **S/E**: Start/End 标志。
        
    - **Type (6 bits)**: 原 NALU 的类型。
        

## 4. AAC over RTP (RFC 3640)

AAC 打包通常不使用分片（因为音频帧很小），主要使用 **AU-Header** 机制来支持在一个 RTP 包中聚合多个音频帧。

### 结构

Plaintext

```
[ RTP Header ] [ AU-Headers-Length (2B) ] [ AU-Header 1 ] [ AU-Header 2 ] ... [ AAC Data 1 ] [ AAC Data 2 ]
```

- **AU-Headers-Length**: 单位是 bit。表示后面紧跟的 AU-Header 部分的总长度。
    
- **AU-Header**: 描述对应 AAC Data 的大小。通常配置为 13 bits Size + 3 bits Index/Delta。
    

> **注意**：AAC over RTP 封装时，**必须去掉 ADTS 头**（那个 FFF 开头的 7 字节头），只保留裸流数据。接收端如果需要播放，可能需要重新加上 ADTS 头或通过 SDP 配置解码器。