
---

# 📘 深度手册：SWS 图像缩放算法全解析

**Deep Dive into Image Scaling Algorithms: SWS Modes**

> 💡 **核心摘要**：图像缩放（Image Scaling）不仅是像素的重采样，更是**几何空间映射**的艺术。其核心矛盾在于：源图像的**物理形状（宽高比）与目标显示设备的物理形状**往往不一致。
> 
> 算法的任务，就是在**“保留画面内容”**、**“维持几何比例”**和**“填充显示区域”**这三者之间，根据业务需求做出数学上的取舍。

---

## 📐 第一部分：几何基础 (Geometric Foundations)

### 1. 宽高比 (Aspect Ratio, AR)

这是决定缩放逻辑的唯一物理量。

$$AR = \frac{Width}{Height}$$

- **源宽高比 (`src_aspect`)**：图像本身的形状。例如 16:9 (1.77) 的电影，或 9:16 (0.56) 的手机截图。
    
- **目标宽高比 (`dst_aspect`)**：显示窗口的形状。例如 4:3 (1.33) 的老式电视，或 1:1 (1.0) 的 Instagram 头像框。
    

### 2. 相对几何关系

当我们比较 `src_aspect` 和 `dst_aspect` 时，实际上是在判断图像相对于屏幕是**“更扁”**还是**“更瘦”**：

- **`src_aspect > dst_aspect`**：**横向主导**。意味着图像比屏幕更“扁宽”。
    
    - _例子_：在 4:3 的 iPad 上看 16:9 的电影。
        
- **`src_aspect < dst_aspect`**：**纵向主导**。意味着图像比屏幕更“瘦高”。
    
    - _例子_：在 16:9 的电脑屏幕上看 9:16 的手机竖屏视频。
        

---

## 🖼️ 第二部分：三种核心模式深度剖析

我们用一个通俗的例子贯穿：**“把一张 16:9 的宽电影海报，贴到一面 4:3 的正方形墙上。”**

### 1. 模式一：SCALE_TO_FILL (强制铺满 / 拉伸)

**——“只要填满，不顾死活”**

- **视觉现象**：
    
    - 图像会被**非等比拉伸**。
        
    - 如果是宽图放入窄屏幕，物体会被“挤瘦”。
        
    - 如果是高图放入宽屏幕，物体会被“压扁”。
        
    - **圆形会变成椭圆，正方形会变成长方形。**
        
- **几何原理**：
    
    - 完全放弃“宽高比保持”原则。
        
    - X 轴和 Y 轴使用**独立**的缩放系数，互不干扰。
        
- 数学公式：
    
    $$W_{final} = W_{dst}, \quad H_{final} = H_{dst}$$
    
- **应用场景**：
    
    - **纯色背景/渐变背景**：没有具体形状物体，变形也看不出来。
        
    - **UI 控件底图**：按钮、面板背景，需要随文字长度自由伸缩。
        

---

### 2. 模式二：SCALE_WITH_BORDERS (适应 / Letterbox)

**——“宁缺毋滥，完整第一”**

- **视觉现象**：
    
    - **内容完整**：保证你能看到图像的每一个像素。
        
    - **黑边 (Padding)**：为了维持比例且放入屏幕，必然会在某一方向上留空。
        
        - 上下黑边叫 **Letterbox**（常见于电影）。
            
        - 左右黑边叫 **Pillarbox**（常见于老电视节目）。
            
- **几何原理 (The "Contain" Logic)**：
    
    - 必须把图像**完全包裹**在目标矩形内。
        
    - 这意味着缩放受到**较短那一边**的限制（木桶效应）。
        
- **算法推导**：
    
    - **场景 A**：`src` 比 `dst` 更宽 (16:9 图 -> 4:3 屏)。
        
        - _瓶颈_：**宽度**会先碰到屏幕边缘。
            
        - _决策_：以**宽度**为基准缩放 -> $Scale = W_{dst} / W_{src}$。
            
    - **场景 B**：`src` 比 `dst` 更高 (9:16 图 -> 4:3 屏)。
        
        - _瓶颈_：**高度**会先碰到屏幕边缘。
            
        - _决策_：以**高度**为基准缩放 -> $Scale = H_{dst} / H_{src}$。
            
- **应用场景**：
    
    - **视频播放器**：用户看电影时，绝对不能接受画面被切掉。
        
    - **图片预览**：查看原图模式。
        

---

### 3. 模式三：SCALE_TO_FIT_AND_ZOOM (填充 / Crop)

**——“必须填满，多余切掉”**

- **视觉现象**：
    
    - **无黑边**：屏幕被完全覆盖，沉浸感最强。
        
    - **内容裁切 (Clipping)**：图像的边缘部分会超出屏幕范围（通常被丢弃）。
        
- **几何原理 (The "Cover" Logic)**：
    
    - 目标矩形必须被图像**完全覆盖**。
        
    - 这意味着缩放必须满足**较长那一边**的需求，短边随之溢出。
        
- **算法推导**：
    
    - **场景 A**：`src` 比 `dst` 更宽 (16:9 图 -> 4:3 屏)。
        
        - _需求_：为了填满屏幕高度，宽度必须继续放大，直到高度达标。
            
        - _决策_：以**高度**为基准缩放 -> $Scale = H_{dst} / H_{src}$ (此时宽度会溢出)。
            
    - **场景 B**：`src` 比 `dst` 更高 (9:16 图 -> 4:3 屏)。
        
        - _需求_：为了填满屏幕宽度，高度必须继续放大。
            
        - _决策_：以**宽度**为基准缩放 -> $Scale = W_{dst} / W_{src}$ (此时高度会溢出)。
            
- **应用场景**：
    
    - **短视频 APP**：抖音/TikTok 全屏模式，宁可切掉两边，也要填满手机屏幕。
        
    - **缩略图/头像**：必须填满正方形框。
        

---

## 🧮 第三部分：算法实现的逻辑闭环

在代码实现中，我们不仅要计算**大小 (Size)**，通常还需要计算**位置 (Position)**，即如何将缩放后的图像**居中**。

### 1. 统一的计算流程

1. **计算缩放比例 (Scale Factor)**
    
2. **计算最终尺寸 (Scaled Size)**
    
3. **计算居中偏移 (Centering Offset)**
    

### 2. C++ 实现


```C++
struct Rect { int x, y, w, h; };

Rect calculate_layout(int src_w, int src_h, int dst_w, int dst_h, ScaleMode mode) {
    // 1. 基础浮点数转换，避免整数除法丢失精度
    double sw = static_cast<double>(src_w);
    double sh = static_cast<double>(src_h);
    double dw = static_cast<double>(dst_w);
    double dh = static_cast<double>(dst_h);

    // 计算源和目标的宽高比
    double src_aspect = sw / sh;
    double dst_aspect = dw / dh;
    
    double scale = 1.0;

    // --- 核心逻辑分支 ---
    if (mode == SCALE_TO_FILL) {
        // 模式一：拉伸。宽高各自独立缩放，不需要单一的 scale 系数
        return {0, 0, (int)dst_w, (int)dst_h}; 
    }
    
    // 对于模式二和三，我们需要比较宽高比
    bool src_is_wider = src_aspect > dst_aspect;

    if (mode == SCALE_WITH_BORDERS) {
        // 模式二：Fit (适应)。
        // 逻辑：谁超出了，就以谁为基准压缩。
        // 如果图比屏宽 (src_is_wider)，说明宽度是瓶颈，以宽度算比例。
        // 如果图比屏高 (!src_is_wider)，说明高度是瓶颈，以高度算比例。
        if (src_is_wider) scale = dw / sw;
        else              scale = dh / sh;
    } 
    else if (mode == SCALE_TO_FIT_AND_ZOOM) {
        // 模式三：Crop (填充)。
        // 逻辑：谁不够填满，就以另一边为基准放大。
        // 如果图比屏宽 (src_is_wider)，说明高度不够填满，必须按高度放大 (宽度会溢出)。
        // 如果图比屏高 (!src_is_wider)，说明宽度不够填满，必须按宽度放大 (高度会溢出)。
        if (src_is_wider) scale = dh / sh;
        else              scale = dw / sw;
    }

    // --- 结果输出 ---
    
    // 2. 计算最终宽高
    int final_w = static_cast<int>(sw * scale);
    int final_h = static_cast<int>(sh * scale);

    // 3. 计算居中偏移量 (Center the image)
    // 公式：(容器尺寸 - 内容尺寸) / 2
    // 对于 Crop 模式，这里会出现负数，代表向左/上移动，正好实现“裁剪中心”效果
    int off_x = (dst_w - final_w) / 2;
    int off_y = (dst_h - final_h) / 2;

    return {off_x, off_y, final_w, final_h};
}
```

### 3. 为什么代码里是反的？

仔细观察你会发现一个有趣的数学对称性：

- **Fit 模式**：图宽时，用 `dst_width / src_width`。
    
- **Crop 模式**：图宽时，用 `dst_height / src_height`。
    

**本质原因**：

- **Fit** 是求“内接矩形”，受限于**较长**的那个轴（相对比例来说）。
    
- **Crop** 是求“外切矩形”，受限于**较短**的那个轴（要把它拉长直到填满）。
    
- 宽高比的比较 (`src > dst`) 正好帮助我们判断了哪一边是长轴，哪一边是短轴。
    

---

## 🚀 第四部分：总结 (The Takeaway)

选择哪种模式，取决于你对**“内容丢失”**和**“黑边”**的容忍度：

|**维度**|**SCALE_TO_FILL (拉伸)**|**SCALE_WITH_BORDERS (适应)**|**SCALE_TO_FIT_AND_ZOOM (填充)**|
|---|---|---|---|
|**几何形状**|❌ 变形|✅ 保持原样|✅ 保持原样|
|**画面完整性**|✅ 完整|✅ 完整|❌ **边缘丢失**|
|**屏幕覆盖率**|✅ 100% 铺满|❌ **有黑边**|✅ 100% 铺满|
|**数学本质**|独立缩放|取最小比例 `Min(Sx, Sy)`|取最大比例 `Max(Sx, Sy)`|
|**典型代表**|桌面壁纸(拉伸版)|电影播放器|抖音/手机全屏模式|