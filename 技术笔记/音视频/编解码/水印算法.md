# 叠加水印的算法设计

## 软件叠加

### 1. 核心宏：`FAST_BLEND`

```C++
#define FAST_BLEND(fg, bg, alpha)  ((((fg) * (alpha)) + ((bg) * (256 - (alpha)))) >> 8)
```

算法原理：Alpha 混合 (Linear Interpolation)

标准的 Alpha 混合公式是：

```latex
$$Out = Foreground \times \alpha + Background \times (1 - \alpha)$$
```

其中 $\alpha$ 通常是 $0 \sim 1$ 的浮点数。在计算机图形中，$\alpha$ 通常是 $0 \sim 255$ 的整数。

准确的整数公式应该是：

```latex
$$Out = \frac{FG \times A + BG \times (255 - A)}{255}$$
```

**设计思路：用位移换速度**

- **除法是 CPU 的毒药**：整数除法指令（DIV）需要几十个 CPU 周期。
- **位移是 CPU 的美酒**：右移指令（SHR）只需要 1 个周期。
- **近似优化**：将除数 $255$ 近似为 $256$。
  - $x / 256$ 等价于 `x >> 8`。
  - 为了保持能量守恒，如果不透明度是 $A$，透明度就近似看作 $256 - A$。
- **效果**：极大提升了像素混合循环的吞吐量，虽然有 $\frac{1}{256}$ 的微小亮度误差，但在人眼看来完全不可见。

### 2. 函数详解：`blendMask`

#### 第一部分：防御性检查与格式校验

```C++
// 1. 空指针检查：防止访问空内存导致 Crash
if (!dst_frame || !surface || !surface->pixels) return;
// 2. 尺寸检查：如果裁剪后宽度或高度无效，直接跳过
if (params.clipped_w <= 0 || params.clipped_h <= 0) return;

// 3. 格式强校验：本算法仅针对 YUV420P (I420) 优化
// 如果传入 NV12 (UV交织) 或 RGB，内存布局不同，强行计算会花屏或越界
if (dst_frame->format != AV_PIX_FMT_YUV420P) {
    ErrorL << "DrawText::blendMask only supports AV_PIX_FMT_YUV420P...";
    return;
}

// 4. 绝对越界检查：如果起始点或结束点完全在画面外，直接返回
if (params.dest_x < 0 || params.dest_y < 0 ||
    params.dest_x + params.clipped_w > dst_frame->width ||
    params.dest_y + params.clipped_h > dst_frame->height) {
    return;
}
```

#### 第二部分：`YUV` 对齐与坐标计算 (核心难点)

```C++
// 为了让 UV 混合逻辑简单，我们强制让 Y 的渲染起始点对齐到偶数坐标。
// 比如：如果 dest_x 是 3，我们强制对齐到 2。
const int dest_x_aligned = (params.dest_x / 2) * 2;
const int dest_y_aligned = (params.dest_y / 2) * 2;

// 计算对齐产生的“偏差”。
// 如果原坐标是 3，对齐到 2，偏差就是 1。
// 这个偏差意味着我们需要从字体 Mask 的第 1 列开始读，而不是第 0 列。
const int align_dx = params.dest_x - dest_x_aligned;
const int align_dy = params.dest_y - dest_y_aligned;

// 根据偏差，反推 Mask (Source) 的读取起始点
int src_start_x = params.src_x_offset - align_dx;
int src_start_y = params.src_y_offset - align_dy;

// 设置目标帧 (Destination) 的实际写入起始点（偶数）
int dst_start_x = dest_x_aligned;
int dst_start_y = dest_y_aligned;
```

#### 第三部分：负坐标处理 (Negative Clipping)

```C++
// 如果 Source 起始点是负数（比如文字左边 10 像素在屏幕外）
if (src_start_x < 0) {
    int shift = -src_start_x; // 计算偏移量 (10)
    dst_start_x += shift;     // 目标向右移 10 (从屏幕边缘 0 开始写变成从 10 开始？不对，通常 dst_start_x 初始就在边缘)
                              // 修正：这里通常是因为 params.dest_x 就是负数导致的。
                              // 逻辑：跳过屏幕外的部分，调整 dst 起点，重置 src 起点为 0。
    src_start_x = 0;
}
// Y 轴同理
if (src_start_y < 0) {
    int shift = -src_start_y;
    dst_start_y += shift;
    src_start_y = 0;
}
```

#### 第四部分：计算最终有效渲染区域 (Effective Region)

```C++
// Mask 还能读多少像素？
int available_src_w = surface->w - src_start_x;
int available_src_h = surface->h - src_start_y;

// 取三者最小值，这就是最终循环要跑的次数
// dst_frame->width - dst_start_x：防止写出屏幕右边缘
int effective_w = std::min({ params.clipped_w, available_src_w, dst_frame->width - dst_start_x });
int effective_h = std::min({ params.clipped_h, available_src_h, dst_frame->height - dst_start_y });

// 判断边界
if (effective_w <= 0 || effective_h <= 0) return;
```

#### 第五部分：Y 通道 (亮度) 混合

C++

```C++
// data[0] 是 Y 平面。定位到起始内存地址。
uint8_t *dst_y_ptr = dst_frame->data[0] + dst_start_y * dst_frame->linesize[0] + dst_start_x;
// Mask 的起始内存地址。
const uint8_t *src_mask_base = surface->pixels.get() + src_start_y * surface->pitch + src_start_x;

for (int i = 0; i < effective_h; ++i) {
    // 获取当前行的指针
    const uint8_t *mask_row = src_mask_base + i * surface->pitch;
    uint8_t *dst_row = dst_y_ptr + i * dst_frame->linesize[0];
    
    for (int j = 0; j < effective_w; ++j) {
        const unsigned alpha = mask_row[j];
        
        // 1. 完全透明：什么都不做，省去计算，直接 continue
        if (alpha == 0) continue;
        
        // 2. 完全不透明：直接内存赋值，比混合公式快
        if (alpha == 255) {
            dst_row[j] = color.y;
        } 
        // 3. 半透明：使用宏进行快速混合
        else {
            dst_row[j] = static_cast<uint8_t>(FAST_BLEND(color.y, dst_row[j], alpha));
        }
    }
}
```

#### 第六部分：UV 通道参数计算

准备处理色度（颜色）。注意所有的尺寸和坐标都要 **除以 2**。

C++

```C++
// 坐标除以 2
int dest_uv_x = dst_start_x / 2;
int dest_uv_y = dst_start_y / 2;

// 宽高除以 2，向上取整 (effective_w + 1) / 2
// 为什么要 +1？防止奇数宽度时，最后一个像素没颜色。
int clipped_uv_w = (effective_w + 1) / 2;
int clipped_uv_h = (effective_h + 1) / 2;

// 计算 UV 平面的物理剩余空间
int max_uv_w = dst_frame->width / 2 - dest_uv_x;
int max_uv_h = dst_frame->height / 2 - dest_uv_y;

// 【防越界逻辑】
// 如果计算出的渲染宽大于剩余空间，截断它。
// effective_w = ... 这一行是试图反向修正 Y 的逻辑
if (clipped_uv_w > max_uv_w) {
    clipped_uv_w = std::max(0, max_uv_w);
    effective_w = std::min(effective_w, clipped_uv_w * 2);
}
if (clipped_uv_h > max_uv_h) {
    clipped_uv_h = std::max(0, max_uv_h);
    effective_h = std::min(effective_h, clipped_uv_h * 2);
}

if (clipped_uv_w <= 0 || clipped_uv_h <= 0) return;
```

#### 第七部分：UV 通道 (色度) 混合

算法采用 `2x2` 平均法 (`Downsampling`)。

C++

```C++
// data[1] 是 U, data[2] 是 V
uint8_t *dst_u = dst_frame->data[1] + dest_uv_y * dst_frame->linesize[1] + dest_uv_x;
uint8_t *dst_v = dst_frame->data[2] + dest_uv_y * dst_frame->linesize[2] + dest_uv_x;

// 计算 Mask 在 UV 坐标系下的读取起点
int src_uv_sx = src_start_x / 2;
int src_uv_sy = src_start_y / 2;

for (int i = 0; i < clipped_uv_h; ++i) {
    // 目标行指针
    uint8_t *u_row = dst_u + i * dst_frame->linesize[1];
    uint8_t *v_row = dst_v + i * dst_frame->linesize[2];

    // 【映射逻辑】UV 的第 i 行，对应 Mask 的第 2*i 行
    int my = src_uv_sy * 2 + i * 2;
    
    // 获取 Mask 这一行的指针
    const uint8_t* mask_row_1 = surface->pixels.get() + my * surface->pitch;
    
    // 获取 Mask 下一行的指针 (用于计算 2x2)。
    // 【Clamp-to-Edge】如果下一行越界了（比如总高13，现在是12），就重复当前行，防止崩溃。
    const uint8_t* mask_row_2 = (my + 1 < surface->h) ? (mask_row_1 + surface->pitch) : mask_row_1;

    for (int j = 0; j < clipped_uv_w; ++j) {
        // 【映射逻辑】UV 的第 j 列，对应 Mask 的第 2*j 列
        int mx = src_uv_sx * 2 + j * 2;
        
        // 边界保护：防止 Mask 读取越界
        if (mx >= surface->w) break;

        // 【核心降采样算法】读取 2x2 块的 Alpha 值
        // 左上
        unsigned a1 = mask_row_1[mx];
        // 右上 (边界检查：如果越界复用左边的)
        unsigned a2 = (mx + 1 < surface->w) ? mask_row_1[mx + 1] : a1;
        // 左下 (边界检查已在 mask_row_2 处理)
        unsigned a3 = (my + 1 < surface->h) ? mask_row_2[mx] : a1;
        // 右下
        unsigned a4 = (mx + 1 < surface->w && my + 1 < surface->h) ? mask_row_2[mx + 1] : a3;

        // 求平均值：(a1+a2+a3+a4) / 4。用位移 >> 2 实现。
        unsigned alpha = (a1 + a2 + a3 + a4) >> 2;
        
        if (alpha == 0) continue;

        if (alpha == 255) {
            u_row[j] = color.u;
            v_row[j] = color.v;
        } else {
            // 对 U 和 V 分别做混合
            u_row[j] = static_cast<uint8_t>(FAST_BLEND(color.u, u_row[j], alpha));
            v_row[j] = static_cast<uint8_t>(FAST_BLEND(color.v, v_row[j], alpha));
        }
    }
}
```