# 高性能 CPU 软绘 YUV 画框算法核心技术解析

## 1. 概述 (Overview)

本算法旨在解决在 CPU 软解/软绘场景下，对 1080P/4K YUV420P 视频流进行**高性能、低延迟、无副作用**的矩形框（OSD）绘制。核心设计理念围绕**零拷贝（Zero-Copy）**、**物理正确性**以及**硬件亲和性**展开，将像素填充速度压榨至硬件极限。

------

## 2. 核心技术实现 (Core Implementation)

### 2.1 数学核心：定点数运算与位移优化

算法最底层的“原子”操作，通过牺牲极微小的精度换取数十倍的指令吞吐量提升。

- **核心宏定义**：

  C++

  ```
  #define FAST_BLEND(fg, bg, alpha, inv_alpha) ((((fg) * (alpha)) + ((bg) * (inv_alpha))) >> 8)
  ```

- **原理剖析**：

  - **标准公式（浮点/除法）**： `Result = (FG * A + BG * (255 - A)) / 255`
    - *痛点*：CPU 整数除法指令（IDIV）极其昂贵，耗时约 **20~80 个 CPU 周期**。在百万级像素处理中是绝对的性能瓶颈。
  - **优化公式（定点/位移）**： `Result = (FG * A + BG * (256 - A)) >> 8`
    - *原理*：将分母从 255 近似为 256，利用位移指令（`>> 8`）替代除法。
    - *收益*：位移指令仅需 **1 个 CPU 周期**。
    - *误差*：`1/256 ≈ 0.39%` 的亮度误差，人眼完全无法察觉。

### 2.2 几何解构：防止“双重混合”的拓扑切割

在半透（Alpha < 255）场景下，必须杜绝像素的**重复绘制**。若矩形框的边角重叠，会导致该区域颜色变深（脏角）。

- **拓扑策略：“H型”切割** 算法将矩形框拆解为四个**互不重叠**的几何区域：

  1. **Top (上边)**：占据完整的宽度 `[left, right)`。
  2. **Bottom (下边)**：占据完整的宽度 `[left, right)`。
  3. **Left (左边)**：高度被压缩，**避开**上下边框。
     - `Y_start = Top + Thickness`
     - `Y_end = Bottom - Thickness`
  4. **Right (右边)**：同左边，只绘制中间段。

- **代码逻辑映射**：

  C++

  ```
  // 垂直区域避让逻辑
  const int y_vertical_start = top + ((borders & TOP) ? thickness : 0);
  const int y_vertical_end = bottom - ((borders & BOTTOM) ? thickness : 0);
  ```

- **效果**：从几何上保证了**每个像素只被计算一次混合**，彻底消除了半透明叠加时的颜色错误。

### 2.3 物理架构：YUV 内存分层处理

YUV420P 是一种 Planar（平面）格式，且存在色度下采样（Sub-sampling），这是导致画框代码出现颜色错位或 Crash 的根源。

- **物理存储模型**：

  - **Y 平面**：`Width * Height` （全分辨率）
  - **U/V 平面**：`(Width/2) * (Height/2)` （1/4 数据量）
  - **映射关系**：Y 平面上的 `2x2` 像素块共用 UV 平面上的 1 个点。

- **循环分离策略**：

  - *错误做法*：在遍历 Y 行的循环中同步绘制 UV。会导致偶数行和奇数行的 Y 使得同一行 UV 被重复绘制两次（颜色叠加变深）。

  - *正确做法*：**Y 循环与 UV 循环完全独立**。

    1. 先跑完 Y 平面绘制。

    2. 计算对应的 UV 行范围：

       C++

       ```
       const int uv_top = y_start / 2;         // 向下取整
       const int uv_bottom = (y_end - 1) / 2; // 覆盖所有涉及行
       ```

    3. 独立遍历 UV 平面，确保每行 UV 只被处理一次。

### 2.4 硬件加速策略：榨干 CPU 性能

通过代码结构诱导编译器和 CPU 进行硬件级优化。

1. **SIMD 隐式调用 (`std::memset`)**：
   - 针对 **全不透明 (Alpha=255)** 场景，直接调用 `std::memset`。
   - `memset` 会自动利用 CPU 的 AVX/SSE 指令集（单次处理 128/256 位），达到内存写入速度的物理极限。
2. **分支预测优化 (Branch Prediction)**：
   - 将 `if (alpha == 255)` 判断提至 `for` 循环外。
   - 循环内部无条件跳转，CPU 流水线满载运行，无分支预测失败惩罚。
3. **缓存局部性 (Cache Locality)**：
   - **横向绘制**：内存地址连续，完美契合 CPU 硬件预取器（Prefetcher）。
   - **纵向绘制**：虽然存在跨行跳跃，但因边框较细（如 4-10px），数据块极小，能完全驻留在 L1 Cache 中，极大减少 Cache Miss。

------



## 3. 整体处理工作流 (Workflow Pipeline)

整个算法流程分为三个严格的阶段：

### 阶段一：预计算 (Pre-computation)

*目标：将高昂的浮点运算和字符串解析移出渲染热路径。*

1. **配置接收**：解析业务层传入的 `BoxParams`（Hex 颜色、坐标、粗细）。
2. **颜色转换**：将 Hex 字符串解析并通过浮点公式转换为 YUV 分量。
3. **缓存**：将转换后的结构体 `YUVColor` (y, u, v, a) 存入缓存列表。

### 阶段二：几何解构 (Geometric Decomposition)

*目标：简化渲染逻辑，保证拓扑正确性。*

1. **边界裁剪**：使用 `std::clamp` 确保坐标在图像有效范围内。
2. **拓扑拆分**：执行“H型”切割，计算出 Top, Bottom, Left, Right 四个互不重叠的矩形区域坐标。

### 阶段三：光栅化渲染 (Rasterization)

*目标：极速像素填充。*

1. **模式选择**：检查 Alpha 值。
   - Alpha = 255 -> **极速模式** (Memset)。
   - Alpha < 255 -> **混合模式** (FAST_BLEND)。
2. **通道渲染**：
   - **Y 通道**：按照拆分后的区域直接填充。
   - **UV 通道**：计算对应缩减后的坐标范围，独立循环填充。

------



## 4. 总结

### 1. `DrawBox::inputFrame`：入口与几何裁剪

```C++
int DrawBox::inputFrame(AVFrame *frame) {
    // 【安全检查】
    // 1. frame 为空或者指针悬空，直接返回。
    // 2. 格式校验：本算法是针对 Planar YUV420P 内存布局写的硬编码优化，
    //    如果传入 NV12 (UV交织) 或 RGB，内存偏移量会完全错误，导致花屏或崩溃。
    if (!frame || frame->format != AV_PIX_FMT_YUV420P) {
        return -1;
    }

    // 没有任何框配置，直接成功返回，不消耗 CPU
    if (_boxes.empty())
        return 0;

    // 遍历所有配置好的框
    for (size_t i = 0; i < _boxes.size(); ++i) {
        const auto &box = _boxes[i];
        const auto &yuv_color = _yuv_colors[i]; // 取出预计算好的 YUV 颜色

        // 【参数过滤】
        // 过滤掉无效的尺寸、无厚度或没有边框标志的配置
        if (box.width <= 0 || box.height <= 0 || box.thickness <= 0 || box.borders == 0)
            continue;

        // 【几何裁剪 - 核心安全逻辑】
        // 防止画框画到屏幕外面导致内存越界 Crash。
        // std::clamp(val, min, max): 确保坐标在 [0, width] 范围内。
        const int x = std::clamp(box.x, 0, frame->width);
        const int y = std::clamp(box.y, 0, frame->height);

        // 计算实际可绘制的宽高。
        // 例如：屏幕宽 1920，x=1900，box.width=100。
        // 实际只能画 20 (1920 - 1900)，否则溢出。
        const int w = std::min(box.width, frame->width - x);
        const int h = std::min(box.height, frame->height - y);

        // 【厚度修正】
        // 如果框很小（例如宽 10），但厚度设了 20，边框会重叠甚至逻辑错乱。
        // 限制厚度最大为宽高的一半，保证几何拓扑不崩坏。
        // 初始化变量 thick，同时检查 w, h, thick 必须大于 0 才有意义。
        if (const int thick = std::min(box.thickness, std::min(w / 2, h / 2)); w > 0 && h > 0 && thick > 0) {
            // 所有坐标校验完毕，进入真正的绘制函数
            drawRegion(frame->data, frame->linesize, x, y, x + w, y + h, thick, yuv_color, box.borders);
        }
    }
    return 0;
}
```

------



### 2. `DrawBox::drawRegion`：拓扑拆解与 YUV 分离



这一层负责**“怎么画”**。它将一个空心矩形拆解为互不重叠的 4 部分，解决半透明叠加变深的问题，并正确调度 Y 和 UV 的绘制。


```C++
void DrawBox::drawRegion(
    uint8_t *dst_data[], const int dst_linesize[], 
    const int left, const int top, const int right, const int bottom, const int thickness,
    const YUVColor &yuv_color, const int borders) {
    
    // 【指针防御】防止传入空数据
    if (!dst_data || !dst_data[0] || !dst_data[1] || !dst_data[2] || !dst_linesize) {
        return;
    }

    // 【透明度优化】
    // 如果颜色完全透明 (Alpha=0)，画了也看不见，直接跳过，节省 CPU。
    const int alpha = yuv_color.a;
    if (alpha == 0)
        return;

    // =========================================================
    // 区域 1：Top (上边框)
    // 策略：绘制完整的水平长条，跨度从 left 到 right
    // =========================================================
    if (borders & TOP) {
        // 计算下边界，防止厚度超过整个框的高度
        const int y_end = std::min(bottom, top + thickness);

        // --- 绘制 Y 平面 (亮度) ---
        // 指针定位：Y 起始地址 + 行偏移
        uint8_t *y_ptr = dst_data[0] + top * dst_linesize[0];
        for (int y = top; y < y_end; ++y) {
            // 调用水平行绘制函数 (利用内存连续性)
            blendRow(y_ptr, left, right, alpha, yuv_color.y);
            // 指针跳到下一行
            y_ptr += dst_linesize[0];
        }

        // --- 绘制 UV 平面 (色度) ---
        // YUV420P 核心：每 2 行 Y 对应 1 行 UV。
        // UV 坐标 = Y 坐标 / 2 (向下取整)
        const int uv_top = top / 2;
        const int uv_bottom = (y_end - 1) / 2; // 覆盖所有涉及的 UV 行
        
        // 独立循环 UV，确保不重复绘制
        for (int uy = uv_top; uy <= uv_bottom; ++uy) {
            // 计算 U 和 V 的行指针
            uint8_t *u_ptr = dst_data[1] + uy * dst_linesize[1];
            uint8_t *v_ptr = dst_data[2] + uy * dst_linesize[2];
            // UV 的水平坐标也是 Y 的一半
            blendRow(u_ptr, left / 2, (right + 1) / 2, alpha, yuv_color.u);
            blendRow(v_ptr, left / 2, (right + 1) / 2, alpha, yuv_color.v);
        }
    }

    // =========================================================
    // 区域 2：Bottom (下边框)
    // 策略：同 Top，绘制完整的水平长条
    // =========================================================
    if (borders & BOTTOM) {
        // 计算起始 Y 坐标
        const int y_start = std::max(top, bottom - thickness);

        // --- 绘制 Y 平面 ---
        uint8_t *y_ptr = dst_data[0] + y_start * dst_linesize[0];
        for (int y = y_start; y < bottom; ++y) {
            blendRow(y_ptr, left, right, alpha, yuv_color.y);
            y_ptr += dst_linesize[0];
        }

        // --- 绘制 UV 平面 ---
        const int uv_top = y_start / 2;
        const int uv_bottom = (bottom - 1) / 2;
        for (int uy = uv_top; uy <= uv_bottom; ++uy) {
            uint8_t *u_ptr = dst_data[1] + uy * dst_linesize[1];
            uint8_t *v_ptr = dst_data[2] + uy * dst_linesize[2];
            blendRow(u_ptr, left / 2, (right + 1) / 2, alpha, yuv_color.u);
            blendRow(v_ptr, left / 2, (right + 1) / 2, alpha, yuv_color.v);
        }
    }

    // =========================================================
    // 区域 3 & 4：Left/Right (垂直边框)
    // 【关键几何算法】：拓扑切割，防止“脏角”
    // 为了不重复绘制角落（Top/Bottom 已经画了），Left/Right 必须避开它们。
    // =========================================================
    
    // 如果 Top 存在，垂直起始点下移 thickness；否则从 top 开始
    const int y_vertical_start = top + ((borders & TOP) ? thickness : 0);
    // 如果 Bottom 存在，垂直结束点上移 thickness；否则到 bottom 结束
    const int y_vertical_end = bottom - ((borders & BOTTOM) ? thickness : 0);

    // 只有中间还有空隙时才画，避免 thickness 过大导致负高度
    if (y_vertical_start < y_vertical_end) {
        
        // --- Left Border ---
        if (borders & LEFT) {
            // 计算右边界 (x)
            const int x_end = std::min(right, left + thickness);
            // 调用矩形块绘制函数 (处理垂直跨行逻辑)
            blendRect(dst_data, dst_linesize, left, x_end, y_vertical_start, y_vertical_end, alpha, yuv_color);
        }

        // --- Right Border ---
        if (borders & RIGHT) {
            // 计算左边界 (x)
            const int x_start = std::max(left, right - thickness);
            blendRect(dst_data, dst_linesize, x_start, right, y_vertical_start, y_vertical_end, alpha, yuv_color);
        }
    }
}
```

------



### 3. `DrawBox::blendRow`：水平行极速混合



这一层负责**内存填充**。对于 Top/Bottom 边框，内存是连续的，这是 CPU 最喜欢的模式。

```C++
void DrawBox::blendRow(uint8_t *row, int x_start, int x_end, int alpha, uint8_t color_val) {
    if (x_start >= x_end)
        return;
    const int width = x_end - x_start;

    // 【硬件加速分支】
    // 如果是不透明 (Alpha=255)，这是最常见的场景。
    // 直接调用 memset。C 标准库的 memset 会自动使用 SIMD (AVX/SSE) 指令一次填充 128/256 位数据。
    // 速度 = 内存带宽极限。
    if (alpha == 255) {
        std::memset(row + x_start, color_val, width);
    } 
    // 【混合运算分支】
    // 如果是半透明，必须逐像素计算。
    else {
        // 预计算反向 Alpha (256 - A)，用于位运算优化
        const int inv_alpha = 256 - alpha;
        
        // 获取起始指针
        uint8_t *ptr = row + x_start;
        
        // 遍历每个像素
        for (int i = 0; i < width; ++i) {
            // 宏展开：((color_val * alpha) + (ptr[i] * inv_alpha)) >> 8
            // 1. 读取内存 ptr[i]
            // 2. 乘法运算
            // 3. 加法运算
            // 4. 位移运算 (替代除法)
            // 5. 写回内存
            ptr[i] = static_cast<uint8_t>(FAST_BLEND(color_val, ptr[i], alpha, inv_alpha));
        }
    }
}
```

------
### 4. `DrawBox::blendRect`：垂直块混合与 YUV 独立调度

负责绘制 Left/Right 这种**垂直条**。这里的难点在于内存不连续（每画一行要跳过整个屏幕宽度），以及 Y 和 UV 的行数不一致。

```C++
void DrawBox::blendRect(uint8_t *dst_data[], const int dst_linesize[], int x_start, int x_end, int y_start, int y_end, int alpha, const YUVColor &yuv_color) {

    // 基本校验
    if (y_start >= y_end || x_start >= x_end)
        return;

    const int width = x_end - x_start;
    const int inv_alpha = 256 - alpha;

    // =========================================================
    // 阶段 1：处理 Y 平面 (全分辨率)
    // =========================================================
    
    // 计算 Y 平面的起始指针位置
    uint8_t *y_ptr = dst_data[0] + y_start * dst_linesize[0] + x_start;
    
    // 遍历每一行高度
    for (int y = y_start; y < y_end; ++y) {
        // 在每一行内部，画一段连续的 width (即 thickness)
        // 虽然这里看起来像 blendRow，但因为 width 很小 (通常 4-10 px)，
        // 这小块数据会常驻 L1 Cache，写入速度极快。
        if (alpha == 255) {
            std::memset(y_ptr, yuv_color.y, width);
        } else {
            for (int i = 0; i < width; ++i) {
                y_ptr[i] = static_cast<uint8_t>(FAST_BLEND(yuv_color.y, y_ptr[i], alpha, inv_alpha));
            }
        }
        // 【关键】：每画完一行，指针必须跳过 linesize，移动到下一行的起始位置
        y_ptr += dst_linesize[0];
    }

    // =========================================================
    // 阶段 2：处理 UV 平面 (半分辨率)
    // 【核心架构设计】：Y 和 UV 循环分离
    // =========================================================
    
    // 1. 计算 UV 的垂直行范围
    const int uv_top = y_start / 2;
    const int uv_bottom = (y_end - 1) / 2; // (end-1) 确保不越界
    if (uv_top > uv_bottom)
        return;

    // 2. 计算 UV 的水平列范围
    const int uv_x_start = x_start / 2;
    const int uv_x_end = (x_end + 1) / 2;
    const int uv_width = uv_x_end - uv_x_start;

    if (uv_width <= 0)
        return;

    // 3. 独立遍历 UV 行
    // 必须独立循环！因为 Y 的第 2n 和 2n+1 行对应同一行 UV。
    // 如果混在 Y 循环里，会导致 UV 被混合两次，颜色变深。
    for (int uy = uv_top; uy <= uv_bottom; ++uy) {
        // 计算 U 和 V 的指针位置
        uint8_t *u_ptr = dst_data[1] + uy * dst_linesize[1] + uv_x_start;
        uint8_t *v_ptr = dst_data[2] + uy * dst_linesize[2] + uv_x_start;

        if (alpha == 255) {
            // 不透明：直接填色
            std::memset(u_ptr, yuv_color.u, uv_width);
            std::memset(v_ptr, yuv_color.v, uv_width);
        } else {
            // 半透明：混合运算
            for (int i = 0; i < uv_width; ++i) {
                u_ptr[i] = static_cast<uint8_t>(FAST_BLEND(yuv_color.u, u_ptr[i], alpha, inv_alpha));
                v_ptr[i] = static_cast<uint8_t>(FAST_BLEND(yuv_color.v, v_ptr[i], alpha, inv_alpha));
            }
        }
    }
}
```