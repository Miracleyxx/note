### 阶段一：定义基础工具 (Utilities)

这是构建系统的地基。

1. **定义 `Packet` (数据包)**

   - 这是在图中流转的基础数据单元。它需要能承载不同类型的数据（例如视频帧、音频帧、控制信令）。

   - **实现**：使用 `std::any` (C++17) 或 `std::shared_ptr<void>` + `type_index` 来实现类型擦除，使其可以容纳任何数据。

   - **关键成员**：`Timestamp` (时间戳)、`Data` (数据本身)。

   - C++

     ```c++
     struct Packet {
         int64_t timestamp;
         std::any data; 
         // 或者：std::shared_ptr<uint8_t> buffer; size_t size;
     };
     ```

2. **实现 `SafeQueue<T>` (线程安全队列)**

   - 这是整个系统多线程的基石。

   - **实现**：使用 `std::queue<T>` 作为内部存储，并用 `std::mutex` 和 `std::condition_variable` 来保护它的 `push` 和 `pop` (或 `try_pop`) 操作。

   - C++

     ```c++
     template<typename T>
     class SafeQueue {
     public:
         void push(T value);
         bool pop(T& value); // 阻塞式
         bool try_pop(T& value); // 非阻塞式
         bool empty();
     private:
         std::queue<T> q_;
         std::mutex mtx_;
         std::condition_variable cv_;
     };
     ```

3. **实现 `SafePriorityQueue<T>` (线程安全优先队列)**

   - 与上面类似，但内部使用 `std::priority_queue<T>`。这用于调度器，以确保高优先级的任务（例如低延迟的音频）先被执行。

### 阶段二：定义核心数据流组件 (Streams)

这些组件负责“线”的逻辑。

1. **定义 `InputStream` (输入流)**
   - 它代表一个节点的“输入引脚”。它的核心是持有一个 `SafeQueue<Packet>`。
   - **关键方法**：`void PushPacket(Packet p)`。当它被调用时，它将数据包放入内部的 `SafeQueue`。
   - **重要**：它还需要持有一个回调函数 `std::function<void()>` (或一个指向其拥有者 `InputStreamManager` 的指针)。当 `PushPacket` 被调用时，它必须**通知**它的管理者：“嘿，我刚收到了一个包，快来检查是否可以创建任务了！”
2. **定义 `OutputStream` (输出流)**
   - 它代表一个节点的“输出引脚”。
   - **关键成员**：`std::vector<InputStream*>` mirrors`。这就是图中的 `Mirror List`。它持有一个或多个下游节点的 `InputStream` 的**指针**。
   - **关键方法**：`void PushPacket(Packet p)`。当它被调用时，它会遍历 `mirrors` 列表，并调用每一个 `InputStream` 的 `PushPacket(p)` 方法，从而将数据广播（或扇出）到所有连接的下游节点。

### 阶段三：定义逻辑与封装 (Module & Node)

这是“节点”的实现。

1. **定义 `Module` (模块 - 抽象基类)**
   - 这是用户定义具体处理逻辑的地方（例如解码、编码、滤镜）。它应该完全解耦，只关心“输入数据”和“输出数据”。
   - **关键方法**：`virtual void Process(const InputData& inputs, OutputData& outputs) = 0;`。
   - *（`InputData` 和 `OutputData` 可以是 `std::map<std::string, Packet>` 这样的结构）*
2. **定义 `InputStreamManager` (ISM)**
   - 由 `Node` 持有。它管理该节点的所有 `InputStream` (例如：`std::map<std::string, std::unique_ptr<InputStream>>`)。
   - **核心职责（最难的部分）**：实现**同步逻辑**。
   - 它接收来自 `InputStream` 的“包已到达”的通知。
   - 它检查“任务触发条件”是否满足（例如：“video”流和“audio”流都至少有一个包）。
   - **当条件满足时**：它从所有相关的 `InputStream` 队列中取出数据包，打包成一个 `Task`，然后将这个 `Task` 提交给 `Scheduler`。
3. **定义 `OutputStreamManager` (OSM)**
   - 由 `Node` 持有。它管理该节点的所有 `OutputStream` (例如：`std::map<std::string, std::unique_ptr<OutputStream>>`)。
   - **核心职责**：在 `Node` 的处理逻辑完成后，被 `Node` 调用。
   - **关键方法**：`void Propagate(const OutputData& outputs)`。它从 `outputs` 中获取数据，并调用相应的 `OutputStream` 的 `PushPacket` 方法。
4. **定义 `Node` (节点)**
   - 这是将 `Module`、`ISM` 和 `OSM` 粘合在一起的“引擎”。
   - **持有**：`std::unique_ptr<Module>`、`std::unique_ptr<InputStreamManager>`、`std::unique_ptr<OutputStreamManager>`。
   - **核心方法**：`void ProcessNode(Task* task)`。这个方法会被 `WorkerThread` 调用。
   - **`ProcessNode` 的逻辑**：
     1. 从 `task` 中解包输入数据 (InQ)。
     2. 调用 `module_->Process(inputs, outputs)`。
     3. 将 `outputs` 存入 `task` 的输出数据 (OutQ) 中。
     4. 调用 `osm_->Propagate(outputs)` (或者这一步在 `Scheduler` 回调中做，取决于设计)。

### 阶段四：定义任务与调度 (Task & Scheduler)

这是驱动整个图运行的“CPU”。

1. **定义 `Task` (任务)**
   - 这是 `Scheduler` 调度的基本工作单元。
   - **持有**：`Node*` (或 `NodeID`)，指向它属于哪个节点；`InputData` (需要处理的输入包)；`OutputData` (用于存放处理结果)。
   - **实现**：可以重载 `operator<`，使其可以被 `SafePriorityQueue` 按时间戳或优先级排序。
2. **定义 `WorkerThread` (工作线程)**
   - 一个简单的类，内部持有一个 `std::thread`。
   - 它在构造时被分配一个 `SafePriorityQueue<Task*>`。
   - **核心逻辑**：在线程循环中，阻塞地从队列中 `pop` 一个 `Task`，然后调用 `task->node->ProcessNode(task)`。
3. **定义 `Scheduler` (调度器)**
   - **持有**：一个线程池（例如 `std::vector<std::unique_ptr<WorkerThread>>`）和对应的任务队列（例如 `std::map<QueueID, std::unique_ptr<SafePriorityQueue<Task*>>>`）。
   - **核心方法**：`void SubmitTask(Task* task)`。
   - **核心逻辑**：当 `ISM` 调用 `SubmitTask` 时，`Scheduler` 根据 `Task` 的属性（例如 `NodeID` 或 `Priority`）决定将这个 `Task` 放入**哪个** `WorkerThread` 的队列中。

### 阶段五：顶层图管理 (Graph)

这是“粘合剂”，负责组装图。

1. **定义 `Graph` (图实例)**
   - **持有**：`std::map<std::string, std::unique_ptr<Node>>` (图中的 `NodesMap`) 和 `std::unique_ptr<Scheduler>`。
   - **核心方法 1**：`Node* AddNode(std::string name, std::unique_ptr<Module> module)`。此方法负责创建 `Node` 实例，并同时为其创建 `ISM` 和 `OSM`。
   - **核心方法 2 (最关键的组装)**：`void Connect(std::string src_node, std::string src_stream, std::string dst_node, std::string dst_stream)`。
   - **`Connect` 的逻辑**：
     1. 找到 `src_node` 的 `OSM`，并获取 `src_stream` (如果不存在则创建)。
     2. 找到 `dst_node` 的 `ISM`，并获取 `dst_stream` (如果不存在则创建)。
     3. 调用 `src_stream_instance->AddMirror(dst_stream_instance)`。**连接完成**。
   - **其他方法**：`Start()` (启动调度器和所有线程)、`Stop()` (停止所有线程)。

1. **先写工具**：`SafeQueue`，`SafePriorityQueue`，`Packet`。
2. **再写数据流**：`InputStream`，`OutputStream`。
3. **然后写核心封装**：`Module` (基类)，`InputStreamManager`，`OutputStreamManager`，`Node`。
4. **接着写驱动**：`Task`，`WorkerThread`，`Scheduler`。
5. **最后写总控**：`Graph`，并实现 `AddNode` 和 `Connect`。