## 字节序

![](https://pic1.zhimg.com/80/v2-d6459e4e2b74f1b240e9122ed359687c_720w.webp)

## 比特序

何谓比特序呢，很好理解，就是`一个字节内的8个bit之间的顺序`。

- 字节序：多个字节的顺序，字节与字节之间的顺序

- 比特序：一个字节内，多个bit的顺序，bit与bit之间的顺序

在一般情况下，比特序的顺序，与字节序是保持一致的。即如果是小端字节序，那么高位bit存在高地址，低位bit存在低地址。

我有一个很好用的办法来区分大小端，即 - `从左往右看，如果符合我们的预期则是大端` - `从右往左看，如果符合我们的预期则是小端`

![](https://pic3.zhimg.com/80/v2-c2d60f8d3af0e07b8eb4c5818aa9833a_720w.webp)

那么问题就来了，既然比特序也区分大小端，那么下面的主机序与网络序的字节序转换函数，是否将比特序也一并进行转换了呢?

```
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
```

就比如上图的194，用大端读是194，用小端读是35，即从左往右看和从右往左看，值是不同的。做了测试之后发现，上面4个函数都没有对比特序做转换。而且写了这么久的代码了，也没见系统提供比特序转换的函数，这就很奇怪了。 我小端接收大端的数据，大端的比特序和小端的顺序不一样，那读出来的字面值肯定不一样啊，咋明明没有对比特序做任何处理，程序安然无恙呢？

在我一开始接触字节序的时候我就在想会不会有比特序这种东西，会不会大小端是反的，不知道读者是否有过这种思考。

举例如下：

```
struct version{
	uint8_t		a : 1; 
	uint8_t		v : 1;
	uint8_t		p : 1
	uint8_t		r : 1; 
	uint8_t		ve : 4; 
}
```

![](https://cdn.nlark.com/yuque/0/2023/jpeg/21994738/1699600754114-62fe7583-a84d-48a5-9b86-2997e5ca2efb.jpeg)

## 网卡-比特的发送和接收顺序

既然在程序中无感知，那么要么是内核，要么是网卡硬件帮我们处理了。比特的发送、接收顺序是指一个字节中的bit在网络电缆中是如何发送、接收的。在以太网(Ethernet)中，是`从最低比特位到最高比特位`的发送顺序，也就是`最低比特位首先发送`。

可以看出发送顺序其实是按照小端序的顺序来发送的。从图中我们可以发现，先发低位bit再发高位bit，这样`对于接收方来说，无需知道对端是大端还是小端，这个数据最左边一定是低位bit，右边一定是高位bit。`

牢记这句人能看懂的话： `协议规定了先发送的bit是低位bit，后发送的是高位bit。那么先接收的一定是低位bit，后接收的一定是高位bit。至于接收之后怎么转换顺序，就看主机是什么端。`

![](https://pic3.zhimg.com/80/v2-8adfcd7b3fb6f39697b14fa405e50dc6_720w.webp)

比特的发送、接收顺序对CPU、软件都是不可见的，因为我们的网卡会给我们处理这种转换，在发送的时候按照`先发低位bit再发高位bit的顺序发送`比特位，在`接收的时候会把接收到的比特序转，换成主机的比特序`。

所以按照这一规定，就能保证在不同的机器之间进行通信不会发生前面担心的字节值发生变化的问题。

### 大端序发送给小端序

![](https://pic1.zhimg.com/80/v2-7bcf874af63bbf9cbba5c2cf84033660_720w.webp)

### 小端序发送给大端序

![](https://pic2.zhimg.com/80/v2-afd989a92de13913bbb53a5730219085_720w.webp)

## 位域

何为位域？就是将一个字节，分成多个区域,如下面结构体所示，一个字节8个bit，被分成了5个区域。

在计算机中可寻址的最小单位为字节，bit是无法寻址的，但是为了抽象我们可以把计算机的最小寻址单位变成bit，也就是我们可以单独获得一个bit位。

位域有一个约定：在C语言的结构体中如果包含了位域，如果位域A定义在位域B之前，那么位域A总是出现在低地址的比特位。 这就决定了网络编程中位域在定义时必须处理大小端问题。(同样，结构体中前面的成员也处于较低的地址)

```
struct bit_order{
    unsigned char a: 2,
                  b: 3,
                  c: 3;
};
```

![](https://pic1.zhimg.com/80/v2-9912da945e703332e873335837a58e50_720w.webp)

我们发现大小端序不同的话，abc对应的值也会不同

```
unsigned char ch      = 121;
struct bit_order *ptr = (struct bit_order *)&ch;
```

![](https://pic3.zhimg.com/80/v2-17274789d921b486dc01268f24643d8a_720w.webp)

## 定义协议的万能公式

一般网络协议都是大端序，大端序低地址存储高位，所以如果主机是小端序，则按照协议规定反着定义位域即可。因为大小端序转换的话，bit位置就是逆序

![](https://pic3.zhimg.com/80/v2-91de1e046c6e9f7ce4c8366f65dc80b6_720w.webp)

举个例子，在websocket的第一个字节中，拿FIN举例，在大端序中它是最低地址0，在小端序中它是最高地址7。

![](https://pic4.zhimg.com/80/v2-3e7bb24fd98878783995ddd0cd277bcf_720w.webp)

```
typedef struct _ws_ophdr {
    unsigned char opcode: 4,
            rsv3: 1,
            rsv2: 1,
            rsv1: 1,
            fin: 1;
    unsigned char payload_len: 7,
            mask: 1;
} ws_ophdr;
```