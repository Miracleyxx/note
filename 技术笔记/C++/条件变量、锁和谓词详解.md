
---

# ğŸ“˜ æŠ€æœ¯æ‰‹å†Œï¼šC++ æ¡ä»¶å˜é‡ (`std::condition_variable`) æ·±åº¦æœºåˆ¶

> ğŸ’¡ **æ ¸å¿ƒç»“è®º**ï¼š`cv.wait(lock, predicate)` æ˜¯ä¸€ä¸ª**åŸå­æ€§**çš„é”ç®¡ç†ä¸çº¿ç¨‹è°ƒåº¦å¤åˆä½“ã€‚åœ¨è°“è¯ï¼ˆPredicateï¼‰ä¸­**ç»ä¸å¯å†æ¬¡åŠ é”**ï¼Œå¦åˆ™å°†å¯¼è‡´æ­»é”æˆ–æœªå®šä¹‰è¡Œä¸ºã€‚

## 1. ğŸ”’ é”ç®¡ç†æœºåˆ¶ï¼šä¸ºä»€ä¹ˆè°“è¯é‡Œä¸éœ€è¦åŠ é”ï¼Ÿ

**ç»“è®º**ï¼š`wait` çš„å¥‘çº¦ä¿è¯äº†â€”â€”**è°“è¯æ°¸è¿œåœ¨æŒæœ‰é”çš„çŠ¶æ€ä¸‹è¢«æ‰§è¡Œ**ã€‚

### `cv.wait(lock, predicate)` çš„å†…éƒ¨åŸå­çŠ¶æ€æœº

è¿™æ˜¯ç†è§£è¯¥æœºåˆ¶çš„å…³é”®ã€‚å½“çº¿ç¨‹æ‰§è¡Œåˆ°è¿™ä¸€è¡Œä»£ç æ—¶ï¼Œåº•å±‚å‘ç”Ÿäº†ä¸¥æ ¼çš„ 6 æ­¥æ“ä½œï¼š

1. **æŒæœ‰é”å…¥åœº**ï¼šè°ƒç”¨ `wait` å‰ï¼Œå½“å‰çº¿ç¨‹**å¿…é¡»**å·²ç»æŒæœ‰äº† `std::unique_lock`ã€‚
    
2. **é¦–æ¬¡è°“è¯æ£€æŸ¥ (Pre-check)**ï¼š
    
    - **çŠ¶æ€**ï¼š**ğŸ”’ å·²åŠ é”**ã€‚
        
    - **åŠ¨ä½œ**ï¼šæ‰§è¡Œ `predicate()`ã€‚
        
    - **åˆ†æ”¯**ï¼šè‹¥ä¸º `true`ï¼Œ`wait` ç›´æ¥è¿”å›ï¼ˆé”ä¿æŒæŒæœ‰ï¼‰ï¼Œä»£ç ç»§ç»­å‘ä¸‹æ‰§è¡Œã€‚
        
3. **åŸå­é‡Šæ”¾ä¸ä¼‘çœ  (Unlock & Sleep)**ï¼š
    
    - **çŠ¶æ€**ï¼š**ğŸ”“ è§£é” -> ğŸ’¤ é˜»å¡**ã€‚
        
    - **åŠ¨ä½œ**ï¼šè‹¥è°“è¯ä¸º `false`ï¼Œ`wait` ä¼š**åŸå­åœ°**é‡Šæ”¾äº’æ–¥é”ï¼Œå¹¶å°†çº¿ç¨‹åŠ å…¥ç­‰å¾…é˜Ÿåˆ—ã€‚
        
    - _æ³¨æ„ï¼šæ­¤æ—¶çº¿ç¨‹è®©å‡ºäº†é”ï¼Œå…¶ä»–çº¿ç¨‹ï¼ˆå¦‚ç”Ÿäº§è€…ï¼‰æ‰èƒ½è·å–é”å¹¶ä¿®æ”¹æ•°æ®ã€‚_
        
4. **å”¤é†’ (Wakeup)**ï¼š
    
    - **è§¦å‘**ï¼šæ”¶åˆ° `notify_one/all` ä¿¡å·ï¼Œæˆ–å‘ç”Ÿ**ä¼ªå”¤é†’ (Spurious Wakeup)**ã€‚
        
    - **çŠ¶æ€**ï¼šå°è¯•ä»æ“ä½œç³»ç»Ÿé‡æ–°è·å–é”ã€‚
        
5. **é‡æ–°æŠ¢é” (Re-lock)**ï¼š
    
    - **åŠ¨ä½œ**ï¼šçº¿ç¨‹é†’æ¥åçš„ç¬¬ä¸€ä»¶äº‹æ˜¯**ç«äº‰äº’æ–¥é”**ã€‚
        
    - _æ³¨æ„ï¼šåœ¨æŠ¢åˆ°é”ä¹‹å‰ï¼Œçº¿ç¨‹ä¼šå¡åœ¨è¿™é‡Œï¼Œä¸ä¼šæ‰§è¡Œä»»ä½•ç”¨æˆ·ä»£ç ã€‚_
        
6. **å†æ¬¡è°“è¯æ£€æŸ¥ (Re-check)**ï¼š
    
    - **çŠ¶æ€**ï¼š**ğŸ”’ å·²åŠ é”**ã€‚
        
    - **åŠ¨ä½œ**ï¼šæŠ¢åˆ°é”åï¼Œå†æ¬¡æ‰§è¡Œ `predicate()`ã€‚
        
    - **åˆ†æ”¯**ï¼šè‹¥ä¸º `true`ï¼Œè¿”å›ï¼ˆå¸¦é”ï¼‰ï¼›è‹¥ä¸º `false`ï¼Œå›åˆ°ç¬¬ 3 æ­¥ï¼ˆé‡Šæ”¾é”å¹¶ç»§ç»­ç¡ï¼‰ã€‚
        

> âš ï¸ **é«˜å±è­¦ç¤º**ï¼šå¦‚æœåœ¨è°“è¯ lambda ä¸­å†™äº† `lock.lock()`ï¼Œç”±äºå½“å‰çº¿ç¨‹åœ¨æ‰§è¡Œè°“è¯æ—¶**æœ¬è´¨ä¸Šå·²ç»æŒæœ‰é”**ï¼Œè¿™å°†å¯¼è‡´å¯¹ä¸å¯é‡å…¥é”çš„é‡å¤åŠ é”ï¼Œç›´æ¥å¼•å‘ **æ­»é” (Deadlock)**ã€‚

## 2. ğŸ‘» ä¼ªå”¤é†’ (Spurious Wakeup)

**å®šä¹‰**ï¼šçº¿ç¨‹åœ¨æ²¡æœ‰æ”¶åˆ°æ˜¾å¼ `notify` çš„æƒ…å†µä¸‹è¢«æ“ä½œç³»ç»Ÿå”¤é†’ã€‚

**æˆå› **ï¼š

- **ç³»ç»Ÿè°ƒåº¦**ï¼šå¤šæ ¸ CPU çš„è°ƒåº¦ä¼˜åŒ–æˆ–ç«äº‰æ¡ä»¶å¤„ç†ã€‚
    
- **ä¿¡å·ä¸­æ–­**ï¼šåº•å±‚çš„ç³»ç»Ÿä¿¡å·å¯èƒ½ä¸­æ–­ `wait` çŠ¶æ€ã€‚
    

**å·¥ç¨‹å½±å“**ï¼š

- `wait` è¿”å›**ä¸ä»£è¡¨**æ¡ä»¶ä¸€å®šæˆç«‹ã€‚
    
- **å¿…é¡»ä½¿ç”¨å¾ªç¯æ£€æŸ¥**ï¼š
    
    - _é”™è¯¯å†™æ³•_ï¼š`if (!condition) cv.wait(lock);` ï¼ˆé†’æ¥åå‡è®¾æ¡ä»¶æˆç«‹ï¼Œå¯èƒ½å¯¼è‡´è®¿é—®è¶Šç•Œï¼‰ã€‚
        
    - _æ­£ç¡®å†™æ³•_ï¼š`while (!condition) cv.wait(lock);`ã€‚
        
    - _æ¨èå†™æ³•_ï¼š`cv.wait(lock, []{ return condition; });` ï¼ˆSTL å†…éƒ¨å·²å°è£…äº† `while` å¾ªç¯ï¼‰ã€‚
        

## 3. ğŸ“£ Notify çš„å†³å®šæ€§ä½œç”¨

è¯¯åŒºï¼šå¾ˆå¤šå¼€å‘è€…è®¤ä¸ºä¿®æ”¹äº†å…±äº«å˜é‡ï¼ˆå¦‚ queue.pushï¼‰ï¼Œç­‰å¾…çº¿ç¨‹å°±ä¼šè‡ªåŠ¨æ£€æµ‹åˆ°ã€‚

äº‹å®ï¼šæ¡ä»¶å˜é‡æ˜¯è¢«åŠ¨çš„ã€‚å¦‚æœæ²¡æœ‰ notifyï¼Œwait çš„çº¿ç¨‹å°±åƒâ€œè£…ç¡çš„äººâ€ï¼Œé™¤äº†ä¼ªå”¤é†’ï¼Œæ°¸è¿œä¸ä¼šé†’æ¥ã€‚

**æ­£ç¡®äº¤äº’æ—¶åº**ï¼š

1. **ç”Ÿäº§è€…**ï¼š
    
    - è·å–é” -> ä¿®æ”¹æ•°æ®ï¼ˆä½¿æ¡ä»¶å¯èƒ½ä¸ºçœŸï¼‰ -> é‡Šæ”¾é”ï¼ˆå¯é€‰ä½†æ¨èï¼‰ -> **å‘é€ `notify`**ã€‚
        
    - _æ³¨ï¼šå…ˆè§£é”å† notify å¯ä»¥é¿å…â€œæƒŠç¾¤æ•ˆåº”â€å¯¼è‡´çš„é”ç«äº‰ï¼Œæå‡æ€§èƒ½ã€‚_
        
2. **æ¶ˆè´¹è€…**ï¼š
    
    - è·å–é” -> `wait(lock, pred)` -> è¢«å”¤é†’å¹¶æŠ¢é” -> æ£€æŸ¥æ•°æ® -> æ¶ˆè´¹ã€‚
        

## 4. ğŸ’» æ ‡å‡†ä»£ç èŒƒå¼ (The Canonical Pattern)

å¤„ç†ç”Ÿäº§è€…-æ¶ˆè´¹è€…çš„æ ‡å‡†æ¨¡æ¿ã€‚

```C++
class ThreadSafeQueue {
    std::vector<int> data_;
    std::mutex mtx_;
    std::condition_variable cv_;

public:
    // ç”Ÿäº§è€…ï¼šä¿®æ”¹æ•°æ® -> é€šçŸ¥
    void push(int val) {
        {
            // 1. åŠ é”ä¿æŠ¤æ•°æ®
            std::lock_guard<std::mutex> lock(mtx_);
            data_.push_back(val);
        } // 2. é”åœ¨æ­¤å¤„ææ„é‡Šæ”¾ (ä¼˜åŒ–æ€§èƒ½ï¼Œé¿å…å”¤é†’çš„çº¿ç¨‹ç«‹å³é˜»å¡åœ¨é”ä¸Š)
        
        // 3. å¿…é¡»æ˜¾å¼é€šçŸ¥ï¼
        cv_.notify_one(); 
    }

    // æ¶ˆè´¹è€…ï¼šç­‰å¾…æ¡ä»¶ -> æ¶ˆè´¹
    void wait_and_process() {
        std::unique_lock<std::mutex> lock(mtx_); // 1. å¿…é¡»ç”¨ unique_lock
        
        // 2. ä½¿ç”¨è°“è¯å¤„ç†ä¼ªå”¤é†’
        // è°“è¯ä¸­ä¸éœ€è¦åŠ é”ï¼Œå› ä¸ºæ­¤æ—¶ lock å·²ç»è¢«å½“å‰çº¿ç¨‹æŒæœ‰
        cv_.wait(lock, [this] { 
            return !data_.empty(); 
        });

        // 3. èµ°åˆ°è¿™é‡Œï¼Œä¿è¯ï¼š
        //    a. é”æ˜¯æŒæœ‰çš„
        //    b. data_ ä¸ä¸ºç©º (é™¤éå…¶ä»–çº¿ç¨‹æŠ¢å…ˆæ¶ˆè´¹äº†ï¼Œä½†åœ¨æŒæœ‰é”æ—¶æ˜¯å®‰å…¨çš„)
        int val = data_.back();
        data_.pop_back();
        
        // ... å¤„ç† val ...
    }
};
```

---

## ğŸš€ æ€»ç»“ (Critical Takeaways)

1. **è°“è¯é›¶é”**ï¼šè°“è¯ Lambda å†…éƒ¨**ä¸éœ€è¦ä¹Ÿä¸å¯ä»¥**åŠ é”ï¼Œ`wait` ä¿è¯å®ƒæ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚
    
2. **Wait æ˜¯ä¸ªå¾ªç¯**ï¼š`wait` = `Unlock` + `Sleep` + `Wakeup` + `Re-lock` + `Check`ã€‚
    
3. **é˜²ä¼ªå”¤é†’**ï¼šæ°¸è¿œä½¿ç”¨ `wait(lock, predicate)` æˆ– `while` å¾ªç¯ï¼Œæ‹’ç» `if`ã€‚
    
4. **å¿…é¡»é€šçŸ¥**ï¼šä¿®æ”¹æ•°æ®åä¸è°ƒ `notify` = åˆ¶é€ æ­»çº¿ç¨‹ã€‚